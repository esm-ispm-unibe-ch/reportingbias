system.file("diabetes.csv", package = "reportingbias")
library(RCurl)
data <- read.csv(getURL("https://raw.githubusercontent.com/esm-ispm-unibe-ch/reportingbias/master/diabetes.csv"))
url <- getURL("https://raw.githubusercontent.com/esm-ispm-unibe-ch/reportingbias/master/diabetes.csv")
data <- read.csv(text=getURL("https://raw.githubusercontent.com/esm-ispm-unibe-ch/reportingbias/master/diabetes.csv"))
rm(url)
# pairwise format
data.pw <- pairwise(t, r, n, data = diabetes, studlab = id, sm="OR")
library(netmeta)
# pairwise format
data.pw <- pairwise(t, r, n, data = diabetes, studlab = id, sm="OR")
# pairwise format
data.pw <- pairwise(t, r, n, data = data, studlab = id, sm="OR")
# run netmeta
nma <- netmeta(TE, seTE, treat1, treat2, studlab=studlab, data = data.pw)
# threshold analysis
threshold_netmeta(nma, opt.max = F)
rm(list=ls())
library(devtools)
install_github("esm-ispm-unibe-ch/reportingbias")
library(reportingbias)
library(RCurl)
library(netmeta)
# download and store dataset
data <- read.csv(text=getURL("https://raw.githubusercontent.com/esm-ispm-unibe-ch/reportingbias/master/diabetes.csv"))
# pairwise format
data.pw <- pairwise(t, r, n, data = data, studlab = id, sm="OR")
View(data)
View(data.pw)
# run netmeta
nma <- netmeta(TE, seTE, treat1, treat2, studlab=studlab, data = data.pw)
# threshold analysis
threshold_netmeta(nma, opt.max = F)
threshold_netmeta
install_github("esm-ispm-unibe-ch/reportingbias", force = T)
library(reportingbias)
library(RCurl)
library(netmeta)
# download and store dataset
data <- read.csv(text=getURL("https://raw.githubusercontent.com/esm-ispm-unibe-ch/reportingbias/master/diabetes.csv"))
# pairwise format
data.pw <- pairwise(t, r, n, data = data, studlab = id, sm="OR")
# run netmeta
nma <- netmeta(TE, seTE, treat1, treat2, studlab=studlab, data = data.pw)
threshold_netmeta
update_packages(packages = "reportingbias")
threshold_netmeta
update_packages(packages = "reportingbias")
update.packages()
rm(list=ls())
install_github("esm-ispm-unibe-ch/reportingbias")
install_github("esm-ispm-unibe-ch/reportingbias", force = T)
library(reportingbias)
threshold_netmeta
matrix.map <- function(x) {
# number of treatment
K <- x$n
# treatment names
if (x$reference.group == "")
trts <- colnames(x$A.matrix)
else
trts <- c(x$reference.group,
colnames(x$A.matrix)[colnames(x$A.matrix) != x$reference.group])
studies.pre <- data.frame(studlab = x$studlab,
treat1 = factor(x$treat1, levels = trts), treat2 = factor(x$treat2, levels = trts),
narms = x$narms[match(x$studlab, x$studies)],
stringsAsFactors = F)
studies <- studies.pre[order(studies.pre$studlab), ]
sel <- studies.pre$treat2 == x$reference.group
studies$treat1[sel] <- studies.pre$treat2[sel]
studies$treat2[sel] <- studies.pre$treat1[sel]
# all (observed) comparisons
comparison <- data.frame(cbind(studies$treat1, studies$treat2))
# unique (observed) comparisons
comparison <- unique(comparison[order(comparison[,1],comparison[,2]), ])
# buils design matrix X
X <- matrix(0, nrow = nrow(comparison), ncol = K-1)
for (i in 1:nrow(X)) {
if (comparison[i, 1] > 1) X[i, comparison[i, 1] - 1]  <- -1
if (comparison[i, 2] > 1) X[i, comparison[i, 2] - 1]  <- 1
}
return(X)
}
library(devtools)
install_github("esm-ispm-unibe-ch/reportingbias")
library(reportingbias)
library(RCurl)
library(netmeta)
# download and store dataset
data <- read.csv(text=getURL("https://raw.githubusercontent.com/esm-ispm-unibe-ch/reportingbias/master/diabetes.csv"))
# pairwise format
data.pw <- pairwise(t, r, n, data = data, studlab = id, sm="OR")
# run netmeta
nma <- netmeta(TE, seTE, treat1, treat2, studlab=studlab, data = data.pw)
# threshold analysis
threshold_netmeta(nma, opt.max = F)
threshold_netmeta
#####   function to run threshold analysis                    #####
####    arguments:  nma, object of class netmeta
####                nma.type (default "random"), if random of fixed effects
####                        used in original analysis
####                opt.max (default TRUE), optimal decision
####                        is the max treat. effect (e.g. for
####                        beneficial outcomes) or the minimum
####                        (e.g. for harmful outcomes)
####                decision (default "decision"), decision rule
####                        based on MCID; if "change" then use
####                        maximum efficacy rule but only changes
####                        the decision when alternative treatment
####                        becomes more effective than base case by mcid or more
####                mcid (default 0 i.e. max efficacy decision rule),
####                        minimally clinical important difference for the decision (if "decision")
####                        or for changing the decision (if "change")
library(nmathresh)
threshold_netmeta <- function(nma, nma.type="random", opt.max=T, decision="decision", mcid=0) {
K <- nma$n  # Number of treatments
X <- matrix.map(nma)  ## check you get same design matrix as above
if (nma.type=="random") {
# create basic parameters based on chosen reference
basicparam<-nma$TE.random[-1, 1] #the basic parameters all vs treat 1
covariance<-nma$Cov.random[1:(K-1), 1:(K-1)] # the variance-covariance between the basic parameters
}
else {
# create basic parameters based on chosen reference
basicparam<-nma$TE.fixed[-1, 1] #the basic parameters all vs treat 1
covariance<-nma$Cov.fixed[1:(K-1), 1:(K-1)] # the variance-covariance between the basic parameters
}
lik.cov<-recon_vcov(covariance, X = X) #reconstruct the variance
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = covariance,
nmatype = "fixed", X = X,
trt.code =  nma$trts, opt.max = opt.max,
mcid = mcid, mcid.type = decision)
return(thresh)
}
# threshold analysis
threshold_netmeta(nma, opt.max = F)
# threshold analysis
threshold_netmeta(nma, opt.max = F, mcid = 0.05)
# threshold analysis
thresh <- threshold_netmeta(nma, opt.max = F, mcid = 0.05)
threshplot <-  function(thresh, nma, nma.type="random", xlab="", xlim = NULL) {
# design matrix of basic parameters
X <- thresh$call$X
# Get indices of contrasts in likelihood in full contrast vector
d.a <- d.b <- vector(length = nrow(X))
for (i in 1:nrow(X)) {
d.a[i] <- ifelse(any(X[i,] == -1), which(X[i,] == -1),0) + 1
d.b[i] <- ifelse(any(X[i,] == 1),which(X[i,] == 1),0) + 1
}
# data points with confidence intervals
if (nma.type=="random") {
contr.mean <- diag(nma$TE.random[d.b, d.a])
CI2.5  <- diag(nma$lower.random[d.b, d.a])
CI97.5 <- diag(nma$upper.random[d.b, d.a])
}
else {
contr.mean <- diag(nma$TE.fixed[d.b, d.a])
CI2.5  <- diag(nma$lower.fixed[d.b, d.a])
CI97.5 <- diag(nma$upper.fixed[d.b, d.a])
}
# Label the contrasts and display using a forest plot, along with 95% confidence intervals
plotdat <- data.frame(lab = paste0(nma$trts[d.b], " vs. ", nma$trts[d.a]),
contr.mean, CI2.5, CI97.5)
# produce forest plot
fp <- thresh_forest(
thresh = thresh,     # Threshold object produced by nma_thresh
y = contr.mean,      # Column of data points
CI.lo = CI2.5, CI.hi = CI97.5,  # Columns of lower and upper limits of CIs
label = contr,       # Column of labels
data = plotdat,      # Data frame containing above data
# -- Plotting options below here --
label.title = "Contrast",
xlab = xlab,
CI.title = "95% Confidence Interval",
xlim = xlim,
refline = 0,
digits = 2, cutoff = 30,
II.cols = rgb(0.72, 0.8, 0.93))
}
threshold_netmeta(nma, opt.max = F, mcid = 0.05)
threshplot <-  function(thresh, nma, nma.type="random", xlab="", xlim = NULL) {
# design matrix of basic parameters
X <- thresh$call$X
# Get indices of contrasts in likelihood in full contrast vector
d.a <- d.b <- vector(length = nrow(X))
for (i in 1:nrow(X)) {
d.a[i] <- ifelse(any(X[i,] == -1), which(X[i,] == -1),0) + 1
d.b[i] <- ifelse(any(X[i,] == 1),which(X[i,] == 1),0) + 1
}
# data points with confidence intervals
if (nma.type=="random") {
contr.mean <- diag(nma$TE.random[d.b, d.a])
CI2.5  <- diag(nma$lower.random[d.b, d.a])
CI97.5 <- diag(nma$upper.random[d.b, d.a])
}
else {
contr.mean <- diag(nma$TE.fixed[d.b, d.a])
CI2.5  <- diag(nma$lower.fixed[d.b, d.a])
CI97.5 <- diag(nma$upper.fixed[d.b, d.a])
}
# Label the contrasts and display using a forest plot, along with 95% confidence intervals
plotdat <- data.frame(lab = paste0(nma$trts[d.b], " vs. ", nma$trts[d.a]),
contr.mean, CI2.5, CI97.5)
# produce forest plot
fp <- thresh_forest(
thresh = thresh,     # Threshold object produced by nma_thresh
y = contr.mean,      # Column of data points
CI.lo = CI2.5, CI.hi = CI97.5,  # Columns of lower and upper limits of CIs
label = contr,       # Column of labels
data = plotdat,      # Data frame containing above data
# -- Plotting options below here --
label.title = "Contrast",
xlab = xlab,
CI.title = "95% Confidence Interval",
xlim = xlim,
refline = 0,
digits = 2, cutoff = 30,
II.title = expression("Invariant Interval and "*tilde(k)*"*"),
II.cols = rgb(0.72, 0.8, 0.93))
}
threshplot(thresh, nma, xlab = "Log OR")
threshplot <-  function(thresh, nma, nma.type="random", xlab="", xlim = NULL) {
# design matrix of basic parameters
X <- thresh$call$X
# Get indices of contrasts in likelihood in full contrast vector
d.a <- d.b <- vector(length = nrow(X))
for (i in 1:nrow(X)) {
d.a[i] <- ifelse(any(X[i,] == -1), which(X[i,] == -1),0) + 1
d.b[i] <- ifelse(any(X[i,] == 1),which(X[i,] == 1),0) + 1
}
# data points with confidence intervals
if (nma.type=="random") {
contr.mean <- diag(nma$TE.random[d.b, d.a])
CI2.5  <- diag(nma$lower.random[d.b, d.a])
CI97.5 <- diag(nma$upper.random[d.b, d.a])
}
else {
contr.mean <- diag(nma$TE.fixed[d.b, d.a])
CI2.5  <- diag(nma$lower.fixed[d.b, d.a])
CI97.5 <- diag(nma$upper.fixed[d.b, d.a])
}
# Label the contrasts and display using a forest plot, along with 95% confidence intervals
plotdat <- data.frame(lab = paste0(nma$trts[d.b], " vs. ", nma$trts[d.a]),
contr.mean, CI2.5, CI97.5)
# produce forest plot
fp <- thresh_forest(
thresh = thresh,     # Threshold object produced by nma_thresh
y = contr.mean,      # Column of data points
CI.lo = CI2.5, CI.hi = CI97.5,  # Columns of lower and upper limits of CIs
label = lab,       # Column of labels
data = plotdat,      # Data frame containing above data
# -- Plotting options below here --
label.title = "Contrast",
xlab = xlab,
CI.title = "95% Confidence Interval",
xlim = xlim,
refline = 0,
digits = 2, cutoff = 30,
II.title = expression("Invariant Interval and "*tilde(k)*"*"),
II.cols = rgb(0.72, 0.8, 0.93))
}
threshplot(thresh, nma, xlab = "Log OR")
threshplot <-  function(thresh, nma, nma.type="random", xlab="", xlim = c(-2, 2)) {
# design matrix of basic parameters
X <- thresh$call$X
# Get indices of contrasts in likelihood in full contrast vector
d.a <- d.b <- vector(length = nrow(X))
for (i in 1:nrow(X)) {
d.a[i] <- ifelse(any(X[i,] == -1), which(X[i,] == -1),0) + 1
d.b[i] <- ifelse(any(X[i,] == 1),which(X[i,] == 1),0) + 1
}
# data points with confidence intervals
if (nma.type=="random") {
contr.mean <- diag(nma$TE.random[d.b, d.a])
CI2.5  <- diag(nma$lower.random[d.b, d.a])
CI97.5 <- diag(nma$upper.random[d.b, d.a])
}
else {
contr.mean <- diag(nma$TE.fixed[d.b, d.a])
CI2.5  <- diag(nma$lower.fixed[d.b, d.a])
CI97.5 <- diag(nma$upper.fixed[d.b, d.a])
}
# Label the contrasts and display using a forest plot, along with 95% confidence intervals
plotdat <- data.frame(lab = paste0(nma$trts[d.b], " vs. ", nma$trts[d.a]),
contr.mean, CI2.5, CI97.5)
# produce forest plot
fp <- thresh_forest(
thresh = thresh,     # Threshold object produced by nma_thresh
y = contr.mean,      # Column of data points
CI.lo = CI2.5, CI.hi = CI97.5,  # Columns of lower and upper limits of CIs
label = lab,       # Column of labels
data = plotdat,      # Data frame containing above data
# -- Plotting options below here --
label.title = "Contrast",
xlab = xlab,
CI.title = "95% Confidence Interval",
xlim = xlim,
refline = 0,
digits = 2, cutoff = 30,
II.title = expression("Invariant Interval and "*tilde(k)*"*"),
II.cols = rgb(0.72, 0.8, 0.93))
}
threshplot(thresh, nma, xlab = "Log OR")
source("design matrix.R")
X <- design(diabetes.nma)  ## check you get same design matrix as above
#####   Bayesian  #####
# create basic parameters based on chosen reference
basicparam <- diabetesJAGS$BUGSoutput$mean$LOR[1:(K-1),1]
SDbasicparam<- diabetesJAGS$BUGSoutput$sd$LOR[1:(K-1),1]### !!! the SDs just to check later
# var-cov matrix of the basic parameters from the simulations list
diabJAGSvcov <- var(diabetesJAGS$BUGSoutput$sims.list$LOR[,1:(K-1),1])
lik.cov<-recon_vcov(diabJAGSvcov, X = X) #reconstruct the variance ### tried with prior.prec=0 as the paper says but does not work  ####
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = diabJAGSvcov,
nmatype = "fixed",
X = X, trt.code =  diabetes.nma$trts,
opt.max = FALSE)
diabetes <- read.csv("CINeMA/diabetes.csv")
diabetes.pw <- pairwise(t, r, n, data = diabetes, studlab = id, sm="OR")
# run netmeta
diabetes.nma <- netmeta(TE, seTE, treat1, treat2, studlab=studlab, data = diabetes.pw)
K <- diabetes.nma$n  # Number of treatments
diabetes <- data
#### NETMETA ####
# pairwise format
diabetes.pw <- pairwise(t, r, n, data = diabetes, studlab = id, sm="OR")
# run netmeta
diabetes.nma <- netmeta(TE, seTE, treat1, treat2, studlab=studlab, data = diabetes.pw)
K <- diabetes.nma$n  # Number of treatments
source("design matrix.R")
X <- design(diabetes.nma)  ## check you get same design matrix as above
#####   Bayesian  #####
# create basic parameters based on chosen reference
basicparam <- diabetesJAGS$BUGSoutput$mean$LOR[1:(K-1),1]
SDbasicparam<- diabetesJAGS$BUGSoutput$sd$LOR[1:(K-1),1]### !!! the SDs just to check later
# var-cov matrix of the basic parameters from the simulations list
diabJAGSvcov <- var(diabetesJAGS$BUGSoutput$sims.list$LOR[,1:(K-1),1])
lik.cov<-recon_vcov(diabJAGSvcov, X = X) #reconstruct the variance ### tried with prior.prec=0 as the paper says but does not work  ####
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = diabJAGSvcov,
nmatype = "fixed",
X = X, trt.code =  diabetes.nma$trts,
opt.max = FALSE)
source("design matrix.R")
X <- design(diabetes.nma)  ## check you get same design matrix as above
#####   Bayesian  #####
# create basic parameters based on chosen reference
basicparam <- diabetesJAGS$BUGSoutput$mean$LOR[1:(K-1),1]
SDbasicparam<- diabetesJAGS$BUGSoutput$sd$LOR[1:(K-1),1]### !!! the SDs just to check later
# var-cov matrix of the basic parameters from the simulations list
diabJAGSvcov <- var(diabetesJAGS$BUGSoutput$sims.list$LOR[,1:(K-1),1])
lik.cov<-recon_vcov(diabJAGSvcov, X = X) #reconstruct the variance ### tried with prior.prec=0 as the paper says but does not work  ####
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = diabJAGSvcov,
nmatype = "fixed",
X = X, trt.code =  diabetes.nma$trts,
opt.max = FALSE)
# create basic parameters based on chosen reference
basicparam<-diabetes.nma$TE.random[-1, 1] #the basic parameters all vs treat 1
### has to take the column instead of the row to match it with the posterior from mcmc in the example ####
covariance<-diabetes.nma$Cov.random[1:(K-1), 1:(K-1)] # the variance-covariance between the basic parameters
lik.cov<-recon_vcov(covariance, X = X) #reconstruct the variance ### tried with prior.prec=0 as the paper says but does not work  ####
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = covariance,
nmatype = "fixed",
X = X, trt.code = diabetes.nma$trts,
opt.max = FALSE)
X <- matrix.map(diabetes.nma)
# create basic parameters based on chosen reference
basicparam<-diabetes.nma$TE.random[-1, 1] #the basic parameters all vs treat 1
### has to take the column instead of the row to match it with the posterior from mcmc in the example ####
covariance<-diabetes.nma$Cov.random[1:(K-1), 1:(K-1)] # the variance-covariance between the basic parameters
lik.cov<-recon_vcov(covariance, X = X) #reconstruct the variance ### tried with prior.prec=0 as the paper says but does not work  ####
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = covariance,
nmatype = "fixed",
X = X, trt.code = diabetes.nma$trts,
opt.max = FALSE)
# Get treatments codes for the contrasts with data
d.a <- d.b <- vector(length = nrow(X))
for (i in 1:nrow(X)){
d.a[i] <- ifelse(any(X[i, ] == -1), which(X[i, ] == -1), 0) + 1
d.b[i] <- ifelse(any(X[i, ] == 1), which(X[i, ] == 1), 0) + 1
}
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = covariance,
nmatype = "fixed",
X = X, trt.code = diabetes.nma$trts,
mcid=0.5, opt.max = FALSE)
thresh
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = covariance,
nmatype = "fixed",
X = X, trt.code = diabetes.nma$trts,
opt.max = FALSE)
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = covariance,
nmatype = "fixed",
X = X, trt.code = diabetes.nma$trts,
opt.max = FALSE, mcid = 0.5)
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = covariance,
nmatype = "fixed",
X = X, trt.code = diabetes.nma$trts,
opt.max = FALSE, mcid = 0.05)
thresh
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = covariance,
nmatype = "fixed",
X = X,
opt.max = FALSE, mcid = 0.05)
thresh
d.a <- d.b <- vector(length = nrow(X))
for (i in 1:nrow(X)){
d.a[i] <- ifelse(any(X[i, ] == -1), which(X[i, ] == -1), 0) + 1
d.b[i] <- ifelse(any(X[i, ] == 1), which(X[i, ] == 1), 0) + 1
}
# transform from d_ab style contrast references into d[i] style from full set of contrast for easy indexing in R
# d.i <- d_ab2i(d.a, d.b, K = K)
# Create plot data
plotdat <- data.frame(lab = paste0(diabetes.nma$trts[d.b], " vs. ", diabetes.nma$trts[d.a]),
contr.mean = diag(diabetes.nma$TE.random[d.b, d.a]),
CI2.5 = diag(diabetes.nma$lower.random[d.b, d.a]),
CI97.5 = diag(diabetes.nma$upper.random[d.b, d.a]))
thresh_forest(thresh, contr.mean, CI2.5, CI97.5, label = lab, data = plotdat,
label.title = "Contrast", xlab = "Log Odds Ratio",
y.title = "Log OR", CI.title = "95% Confidence Interval",
II.title = expression("Invariant Interval and "*tilde(k)*"*"),
II.cols = rgb(.72, .80, .93),
xlim = c(-2, 2), refline = 0, digits = 2)
library(nmathresh)
## SETUP ----------------------------------------------------------------------
# Read in the posterior summaries. These were generated by WinBUGS, and saved
# in a summary format for easier re-use.
load("./Headaches posterior summaries.Rda")
# Posterior means of treatment parameters
post.mean.d <- post.summary$statistics[1:7, "Mean"]
post.cov.d <- post.cov[1:7, 1:7]
## RECONSTRUCT LIKELIHOOD  ----------------------------------------------------
# First, we must reconstruct the likelihood covariance matrix. Note that a flat
# prior with precision 0.0001 was used.
# Contrast design matrix is
X <- matrix(ncol = 7,byrow = TRUE,
# d2 d3 d4 d5 d6 d7 d8
c(1, 0, 0, 0, 0, 0, 0,
0, 0, 1, 0, 0, 0, 0,
0, 0, 0, 1, 0, 0, 0,
0, 0, 0, 0, 1, 0, 0,
0, 0, 0, 0, 0, 1, 0,
0, 0, 0, 0, 0, 0, 1,
0,-1, 0, 0, 1, 0, 0,
0, 0, 0, 0,-1, 1, 0))
# Reconstruct using NNLS
lik.cov <- recon_vcov(post.cov.d,          # Posterior covariance matrix
prior.prec = .0001,  # Prior precision
X = X)               # Contrast design matrix
# Get indices of contrasts in likelihood in full contrast vector
d.a <- d.b <- vector(length = nrow(X))
for (i in 1:nrow(X)) {
d.a[i] <- ifelse(any(X[i,] == -1), which(X[i,] == -1),0) + 1
d.b[i] <- ifelse(any(X[i,] == 1),which(X[i,] == 1),0) + 1
}
d.i <- d_ab2i(d.a, d.b, K = 8)
## THRESHOLD ANALYSIS ---------------------------------------------------------
# Now we can perform threshold analysis at the contrast level.
# Thresholds are derived using the nma_thresh function
thresh <- nma_thresh(mean.dk = post.mean.d,   # Posterior means of treatment effects
lhood = lik.cov,         # Reconstructed likelihood covariance matrix
post = post.cov.d,       # Posterior covariance matrix
# -- Further options below --
nmatype = "fixed",       # Approximate two-stage FE NMA
X = X,                   # Contrast design matrix
opt.max = FALSE,         # Lower treatment effects better
mcid = 0.5,              # Specify MCID for decision rule
mcid.type = "decision")
## SETUP ----------------------------------------------------------------------
# Read in the posterior summaries. These were generated by WinBUGS, and saved
# in a summary format for easier re-use.
load("~/PhD project/Publication bias/A1341Phillippo/m18-3542_supplement1/Headaches posterior summaries.Rda")
## SETUP ----------------------------------------------------------------------
# Read in the posterior summaries. These were generated by WinBUGS, and saved
# in a summary format for easier re-use.
load("~/PhD project/Publication bias/A1341Phillippo/m18-3542_supplement1/Headaches/Headaches posterior summaries.Rda")
## SETUP ----------------------------------------------------------------------
# Read in the posterior summaries. These were generated by WinBUGS, and saved
# in a summary format for easier re-use.
load("~/PhD project/Publication bias/A1341Phillippo/m18-3542_supplement1/Headaches/Headaches posterior summaries.Rda")
library(nmathresh)
## SETUP ----------------------------------------------------------------------
# Read in the posterior summaries. These were generated by WinBUGS, and saved
# in a summary format for easier re-use.
load("~/PhD project/Publication bias/A1341Phillippo/m18-3542_supplement1/Headaches/Headaches posterior summaries.Rda")
## SETUP ----------------------------------------------------------------------
# Read in the posterior summaries. These were generated by WinBUGS, and saved
# in a summary format for easier re-use.
load("./PhD project/Publication bias/A1341Phillippo/m18-3542_supplement1/Headaches posterior summaries.Rda")
## SETUP ----------------------------------------------------------------------
# Read in the posterior summaries. These were generated by WinBUGS, and saved
# in a summary format for easier re-use.
load("~/PhD project/Publication bias/A1341Phillippo/m18-3542_supplement1/Headaches posterior summaries.Rda")
