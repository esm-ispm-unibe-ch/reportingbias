d.b[i] <- ifelse(any(X[i,] == 1),which(X[i,] == 1),0) + 1
}
# data points with confidence intervals
if (nma.type=="random") {
contr.mean <- diag(nma$TE.random[d.b, d.a])
CI2.5  <- diag(nma$lower.random[d.b, d.a])
CI97.5 <- diag(nma$upper.random[d.b, d.a])
}
else {
contr.mean <- diag(nma$TE.fixed[d.b, d.a])
CI2.5  <- diag(nma$lower.fixed[d.b, d.a])
CI97.5 <- diag(nma$upper.fixed[d.b, d.a])
}
# Label the contrasts and display using a forest plot, along with 95% confidence intervals
plotdat <- data.frame(lab = paste0(nma$trts[d.b], " vs. ", nma$trts[d.a]),
contr.mean, CI2.5, CI97.5)
# produce forest plot
fp <- thresh_forest(
thresh = thresh,     # Threshold object produced by nma_thresh
y = contr.mean,      # Column of data points
CI.lo = CI2.5, CI.hi = CI97.5,  # Columns of lower and upper limits of CIs
label = contr,       # Column of labels
data = plotdat,      # Data frame containing above data
# -- Plotting options below here --
label.title = "Contrast",
xlab = xlab,
CI.title = "95% Confidence Interval",
xlim = xlim,
refline = 0,
digits = 2, cutoff = 30,
II.cols = rgb(0.72, 0.8, 0.93))
}
threshold_netmeta(nma, opt.max = F, mcid = 0.05)
threshplot <-  function(thresh, nma, nma.type="random", xlab="", xlim = NULL) {
# design matrix of basic parameters
X <- thresh$call$X
# Get indices of contrasts in likelihood in full contrast vector
d.a <- d.b <- vector(length = nrow(X))
for (i in 1:nrow(X)) {
d.a[i] <- ifelse(any(X[i,] == -1), which(X[i,] == -1),0) + 1
d.b[i] <- ifelse(any(X[i,] == 1),which(X[i,] == 1),0) + 1
}
# data points with confidence intervals
if (nma.type=="random") {
contr.mean <- diag(nma$TE.random[d.b, d.a])
CI2.5  <- diag(nma$lower.random[d.b, d.a])
CI97.5 <- diag(nma$upper.random[d.b, d.a])
}
else {
contr.mean <- diag(nma$TE.fixed[d.b, d.a])
CI2.5  <- diag(nma$lower.fixed[d.b, d.a])
CI97.5 <- diag(nma$upper.fixed[d.b, d.a])
}
# Label the contrasts and display using a forest plot, along with 95% confidence intervals
plotdat <- data.frame(lab = paste0(nma$trts[d.b], " vs. ", nma$trts[d.a]),
contr.mean, CI2.5, CI97.5)
# produce forest plot
fp <- thresh_forest(
thresh = thresh,     # Threshold object produced by nma_thresh
y = contr.mean,      # Column of data points
CI.lo = CI2.5, CI.hi = CI97.5,  # Columns of lower and upper limits of CIs
label = contr,       # Column of labels
data = plotdat,      # Data frame containing above data
# -- Plotting options below here --
label.title = "Contrast",
xlab = xlab,
CI.title = "95% Confidence Interval",
xlim = xlim,
refline = 0,
digits = 2, cutoff = 30,
II.title = expression("Invariant Interval and "*tilde(k)*"*"),
II.cols = rgb(0.72, 0.8, 0.93))
}
threshplot(thresh, nma, xlab = "Log OR")
threshplot <-  function(thresh, nma, nma.type="random", xlab="", xlim = NULL) {
# design matrix of basic parameters
X <- thresh$call$X
# Get indices of contrasts in likelihood in full contrast vector
d.a <- d.b <- vector(length = nrow(X))
for (i in 1:nrow(X)) {
d.a[i] <- ifelse(any(X[i,] == -1), which(X[i,] == -1),0) + 1
d.b[i] <- ifelse(any(X[i,] == 1),which(X[i,] == 1),0) + 1
}
# data points with confidence intervals
if (nma.type=="random") {
contr.mean <- diag(nma$TE.random[d.b, d.a])
CI2.5  <- diag(nma$lower.random[d.b, d.a])
CI97.5 <- diag(nma$upper.random[d.b, d.a])
}
else {
contr.mean <- diag(nma$TE.fixed[d.b, d.a])
CI2.5  <- diag(nma$lower.fixed[d.b, d.a])
CI97.5 <- diag(nma$upper.fixed[d.b, d.a])
}
# Label the contrasts and display using a forest plot, along with 95% confidence intervals
plotdat <- data.frame(lab = paste0(nma$trts[d.b], " vs. ", nma$trts[d.a]),
contr.mean, CI2.5, CI97.5)
# produce forest plot
fp <- thresh_forest(
thresh = thresh,     # Threshold object produced by nma_thresh
y = contr.mean,      # Column of data points
CI.lo = CI2.5, CI.hi = CI97.5,  # Columns of lower and upper limits of CIs
label = lab,       # Column of labels
data = plotdat,      # Data frame containing above data
# -- Plotting options below here --
label.title = "Contrast",
xlab = xlab,
CI.title = "95% Confidence Interval",
xlim = xlim,
refline = 0,
digits = 2, cutoff = 30,
II.title = expression("Invariant Interval and "*tilde(k)*"*"),
II.cols = rgb(0.72, 0.8, 0.93))
}
threshplot(thresh, nma, xlab = "Log OR")
threshplot <-  function(thresh, nma, nma.type="random", xlab="", xlim = c(-2, 2)) {
# design matrix of basic parameters
X <- thresh$call$X
# Get indices of contrasts in likelihood in full contrast vector
d.a <- d.b <- vector(length = nrow(X))
for (i in 1:nrow(X)) {
d.a[i] <- ifelse(any(X[i,] == -1), which(X[i,] == -1),0) + 1
d.b[i] <- ifelse(any(X[i,] == 1),which(X[i,] == 1),0) + 1
}
# data points with confidence intervals
if (nma.type=="random") {
contr.mean <- diag(nma$TE.random[d.b, d.a])
CI2.5  <- diag(nma$lower.random[d.b, d.a])
CI97.5 <- diag(nma$upper.random[d.b, d.a])
}
else {
contr.mean <- diag(nma$TE.fixed[d.b, d.a])
CI2.5  <- diag(nma$lower.fixed[d.b, d.a])
CI97.5 <- diag(nma$upper.fixed[d.b, d.a])
}
# Label the contrasts and display using a forest plot, along with 95% confidence intervals
plotdat <- data.frame(lab = paste0(nma$trts[d.b], " vs. ", nma$trts[d.a]),
contr.mean, CI2.5, CI97.5)
# produce forest plot
fp <- thresh_forest(
thresh = thresh,     # Threshold object produced by nma_thresh
y = contr.mean,      # Column of data points
CI.lo = CI2.5, CI.hi = CI97.5,  # Columns of lower and upper limits of CIs
label = lab,       # Column of labels
data = plotdat,      # Data frame containing above data
# -- Plotting options below here --
label.title = "Contrast",
xlab = xlab,
CI.title = "95% Confidence Interval",
xlim = xlim,
refline = 0,
digits = 2, cutoff = 30,
II.title = expression("Invariant Interval and "*tilde(k)*"*"),
II.cols = rgb(0.72, 0.8, 0.93))
}
threshplot(thresh, nma, xlab = "Log OR")
source("design matrix.R")
X <- design(diabetes.nma)  ## check you get same design matrix as above
#####   Bayesian  #####
# create basic parameters based on chosen reference
basicparam <- diabetesJAGS$BUGSoutput$mean$LOR[1:(K-1),1]
SDbasicparam<- diabetesJAGS$BUGSoutput$sd$LOR[1:(K-1),1]### !!! the SDs just to check later
# var-cov matrix of the basic parameters from the simulations list
diabJAGSvcov <- var(diabetesJAGS$BUGSoutput$sims.list$LOR[,1:(K-1),1])
lik.cov<-recon_vcov(diabJAGSvcov, X = X) #reconstruct the variance ### tried with prior.prec=0 as the paper says but does not work  ####
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = diabJAGSvcov,
nmatype = "fixed",
X = X, trt.code =  diabetes.nma$trts,
opt.max = FALSE)
diabetes <- read.csv("CINeMA/diabetes.csv")
diabetes.pw <- pairwise(t, r, n, data = diabetes, studlab = id, sm="OR")
# run netmeta
diabetes.nma <- netmeta(TE, seTE, treat1, treat2, studlab=studlab, data = diabetes.pw)
K <- diabetes.nma$n  # Number of treatments
diabetes <- data
#### NETMETA ####
# pairwise format
diabetes.pw <- pairwise(t, r, n, data = diabetes, studlab = id, sm="OR")
# run netmeta
diabetes.nma <- netmeta(TE, seTE, treat1, treat2, studlab=studlab, data = diabetes.pw)
K <- diabetes.nma$n  # Number of treatments
source("design matrix.R")
X <- design(diabetes.nma)  ## check you get same design matrix as above
#####   Bayesian  #####
# create basic parameters based on chosen reference
basicparam <- diabetesJAGS$BUGSoutput$mean$LOR[1:(K-1),1]
SDbasicparam<- diabetesJAGS$BUGSoutput$sd$LOR[1:(K-1),1]### !!! the SDs just to check later
# var-cov matrix of the basic parameters from the simulations list
diabJAGSvcov <- var(diabetesJAGS$BUGSoutput$sims.list$LOR[,1:(K-1),1])
lik.cov<-recon_vcov(diabJAGSvcov, X = X) #reconstruct the variance ### tried with prior.prec=0 as the paper says but does not work  ####
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = diabJAGSvcov,
nmatype = "fixed",
X = X, trt.code =  diabetes.nma$trts,
opt.max = FALSE)
source("design matrix.R")
X <- design(diabetes.nma)  ## check you get same design matrix as above
#####   Bayesian  #####
# create basic parameters based on chosen reference
basicparam <- diabetesJAGS$BUGSoutput$mean$LOR[1:(K-1),1]
SDbasicparam<- diabetesJAGS$BUGSoutput$sd$LOR[1:(K-1),1]### !!! the SDs just to check later
# var-cov matrix of the basic parameters from the simulations list
diabJAGSvcov <- var(diabetesJAGS$BUGSoutput$sims.list$LOR[,1:(K-1),1])
lik.cov<-recon_vcov(diabJAGSvcov, X = X) #reconstruct the variance ### tried with prior.prec=0 as the paper says but does not work  ####
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = diabJAGSvcov,
nmatype = "fixed",
X = X, trt.code =  diabetes.nma$trts,
opt.max = FALSE)
# create basic parameters based on chosen reference
basicparam<-diabetes.nma$TE.random[-1, 1] #the basic parameters all vs treat 1
### has to take the column instead of the row to match it with the posterior from mcmc in the example ####
covariance<-diabetes.nma$Cov.random[1:(K-1), 1:(K-1)] # the variance-covariance between the basic parameters
lik.cov<-recon_vcov(covariance, X = X) #reconstruct the variance ### tried with prior.prec=0 as the paper says but does not work  ####
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = covariance,
nmatype = "fixed",
X = X, trt.code = diabetes.nma$trts,
opt.max = FALSE)
X <- matrix.map(diabetes.nma)
# create basic parameters based on chosen reference
basicparam<-diabetes.nma$TE.random[-1, 1] #the basic parameters all vs treat 1
### has to take the column instead of the row to match it with the posterior from mcmc in the example ####
covariance<-diabetes.nma$Cov.random[1:(K-1), 1:(K-1)] # the variance-covariance between the basic parameters
lik.cov<-recon_vcov(covariance, X = X) #reconstruct the variance ### tried with prior.prec=0 as the paper says but does not work  ####
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = covariance,
nmatype = "fixed",
X = X, trt.code = diabetes.nma$trts,
opt.max = FALSE)
# Get treatments codes for the contrasts with data
d.a <- d.b <- vector(length = nrow(X))
for (i in 1:nrow(X)){
d.a[i] <- ifelse(any(X[i, ] == -1), which(X[i, ] == -1), 0) + 1
d.b[i] <- ifelse(any(X[i, ] == 1), which(X[i, ] == 1), 0) + 1
}
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = covariance,
nmatype = "fixed",
X = X, trt.code = diabetes.nma$trts,
mcid=0.5, opt.max = FALSE)
thresh
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = covariance,
nmatype = "fixed",
X = X, trt.code = diabetes.nma$trts,
opt.max = FALSE)
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = covariance,
nmatype = "fixed",
X = X, trt.code = diabetes.nma$trts,
opt.max = FALSE, mcid = 0.5)
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = covariance,
nmatype = "fixed",
X = X, trt.code = diabetes.nma$trts,
opt.max = FALSE, mcid = 0.05)
thresh
thresh <- nma_thresh(mean.dk = basicparam,
lhood = lik.cov,
post = covariance,
nmatype = "fixed",
X = X,
opt.max = FALSE, mcid = 0.05)
thresh
d.a <- d.b <- vector(length = nrow(X))
for (i in 1:nrow(X)){
d.a[i] <- ifelse(any(X[i, ] == -1), which(X[i, ] == -1), 0) + 1
d.b[i] <- ifelse(any(X[i, ] == 1), which(X[i, ] == 1), 0) + 1
}
# transform from d_ab style contrast references into d[i] style from full set of contrast for easy indexing in R
# d.i <- d_ab2i(d.a, d.b, K = K)
# Create plot data
plotdat <- data.frame(lab = paste0(diabetes.nma$trts[d.b], " vs. ", diabetes.nma$trts[d.a]),
contr.mean = diag(diabetes.nma$TE.random[d.b, d.a]),
CI2.5 = diag(diabetes.nma$lower.random[d.b, d.a]),
CI97.5 = diag(diabetes.nma$upper.random[d.b, d.a]))
thresh_forest(thresh, contr.mean, CI2.5, CI97.5, label = lab, data = plotdat,
label.title = "Contrast", xlab = "Log Odds Ratio",
y.title = "Log OR", CI.title = "95% Confidence Interval",
II.title = expression("Invariant Interval and "*tilde(k)*"*"),
II.cols = rgb(.72, .80, .93),
xlim = c(-2, 2), refline = 0, digits = 2)
library(nmathresh)
## SETUP ----------------------------------------------------------------------
# Read in the posterior summaries. These were generated by WinBUGS, and saved
# in a summary format for easier re-use.
load("./Headaches posterior summaries.Rda")
# Posterior means of treatment parameters
post.mean.d <- post.summary$statistics[1:7, "Mean"]
post.cov.d <- post.cov[1:7, 1:7]
## RECONSTRUCT LIKELIHOOD  ----------------------------------------------------
# First, we must reconstruct the likelihood covariance matrix. Note that a flat
# prior with precision 0.0001 was used.
# Contrast design matrix is
X <- matrix(ncol = 7,byrow = TRUE,
# d2 d3 d4 d5 d6 d7 d8
c(1, 0, 0, 0, 0, 0, 0,
0, 0, 1, 0, 0, 0, 0,
0, 0, 0, 1, 0, 0, 0,
0, 0, 0, 0, 1, 0, 0,
0, 0, 0, 0, 0, 1, 0,
0, 0, 0, 0, 0, 0, 1,
0,-1, 0, 0, 1, 0, 0,
0, 0, 0, 0,-1, 1, 0))
# Reconstruct using NNLS
lik.cov <- recon_vcov(post.cov.d,          # Posterior covariance matrix
prior.prec = .0001,  # Prior precision
X = X)               # Contrast design matrix
# Get indices of contrasts in likelihood in full contrast vector
d.a <- d.b <- vector(length = nrow(X))
for (i in 1:nrow(X)) {
d.a[i] <- ifelse(any(X[i,] == -1), which(X[i,] == -1),0) + 1
d.b[i] <- ifelse(any(X[i,] == 1),which(X[i,] == 1),0) + 1
}
d.i <- d_ab2i(d.a, d.b, K = 8)
## THRESHOLD ANALYSIS ---------------------------------------------------------
# Now we can perform threshold analysis at the contrast level.
# Thresholds are derived using the nma_thresh function
thresh <- nma_thresh(mean.dk = post.mean.d,   # Posterior means of treatment effects
lhood = lik.cov,         # Reconstructed likelihood covariance matrix
post = post.cov.d,       # Posterior covariance matrix
# -- Further options below --
nmatype = "fixed",       # Approximate two-stage FE NMA
X = X,                   # Contrast design matrix
opt.max = FALSE,         # Lower treatment effects better
mcid = 0.5,              # Specify MCID for decision rule
mcid.type = "decision")
## SETUP ----------------------------------------------------------------------
# Read in the posterior summaries. These were generated by WinBUGS, and saved
# in a summary format for easier re-use.
load("~/PhD project/Publication bias/A1341Phillippo/m18-3542_supplement1/Headaches posterior summaries.Rda")
## SETUP ----------------------------------------------------------------------
# Read in the posterior summaries. These were generated by WinBUGS, and saved
# in a summary format for easier re-use.
load("~/PhD project/Publication bias/A1341Phillippo/m18-3542_supplement1/Headaches/Headaches posterior summaries.Rda")
## SETUP ----------------------------------------------------------------------
# Read in the posterior summaries. These were generated by WinBUGS, and saved
# in a summary format for easier re-use.
load("~/PhD project/Publication bias/A1341Phillippo/m18-3542_supplement1/Headaches/Headaches posterior summaries.Rda")
library(nmathresh)
## SETUP ----------------------------------------------------------------------
# Read in the posterior summaries. These were generated by WinBUGS, and saved
# in a summary format for easier re-use.
load("~/PhD project/Publication bias/A1341Phillippo/m18-3542_supplement1/Headaches/Headaches posterior summaries.Rda")
## SETUP ----------------------------------------------------------------------
# Read in the posterior summaries. These were generated by WinBUGS, and saved
# in a summary format for easier re-use.
load("./PhD project/Publication bias/A1341Phillippo/m18-3542_supplement1/Headaches posterior summaries.Rda")
## SETUP ----------------------------------------------------------------------
# Read in the posterior summaries. These were generated by WinBUGS, and saved
# in a summary format for easier re-use.
load("~/PhD project/Publication bias/A1341Phillippo/m18-3542_supplement1/Headaches posterior summaries.Rda")
rm(list=ls())
library(devtools)
install_github("esm-ispm-unibe-ch/reportingbias")
library(reportingbias)
library(RCurl)
library(netmeta)
# download and store dataset
data <- read.csv(text=getURL("https://raw.githubusercontent.com/esm-ispm-unibe-ch/reportingbias/master/diabetes.csv"))
# pairwise format
data.pw <- pairwise(t, r, n, data = data, studlab = id, sm="OR")
# run netmeta
nma <- netmeta(TE, seTE, treat1, treat2, studlab=studlab, data = data.pw)
# threshold analysis
thresh <- threshold_netmeta(nma, opt.max = F, mcid = 0.1, decision = "change")
# threshold analysis
thresh <- threshold_netmeta(nma, opt.max = F, mcid = 0.1, decision = "change")
# threshold analysis
thresh <- threshold_netmeta(nma, opt.max = F, mcid = 0.1, decision = "change")
# threshold analysis
thresh <- threshold_netmeta(nma, opt.max = F, mcid = 0.1, decision = "change")
library(nmathresh)
# threshold analysis
thresh <- threshold_netmeta(nma, opt.max = F, mcid = 0.1, decision = "change")
thresh
# threshold analysis
thresh <- threshold_netmeta(nma, opt.max = F, mcid = 0.1)
library(nmadb)
NMADB <- getNMADB()
binaryIDs = NMADB[NMADB$Verified=="True" & NMADB$Type.of.Outcome.=="Binary" & NMADB$Format!="iv",]$Record.ID
continuousIDs = NMADB[NMADB$Verified=="True" & NMADB$Type.of.Outcome.=="Continuous" & NMADB$Format!="iv",]$Record.ID
NMADB[NMADB$Record.ID==474842,]$Harmful.Beneficial.Outcome
NMADB[NMADB$Record.ID==474842,]$Primary.Outcome
NMADB[NMADB$Record.ID==474842,]$Number.of.Treatments
runnetmeta(474842)
nma <- runnetmeta(474842)
summary(nma)
nma$TE.random
thresh <- threshold_netmeta(nma, opt.max = F, mcid = 0.3)
threshplot(thresh, nma, xlab = "Log OR")
thresh <- threshold_netmeta(nma, opt.max = F)
threshplot(thresh, nma, xlab = "Log OR")
NMADB[NMADB$Record.ID==474842, c("Primary.Outcome", "Harmful.Beneficial.Outcome")]
NMADB[Record.ID==474842, c("Primary.Outcome", "Harmful.Beneficial.Outcome")]
NMADB["Record.ID"==474842, c("Primary.Outcome", "Harmful.Beneficial.Outcome")]
thresh <- threshold_netmeta(nma, opt.max = F, mcid = 0.1)
threshplot(thresh, nma, xlab = "Log OR")
library(nmathresh)
nma_thresh
library(devtools)
install_github("esm-ispm-unibe-ch/reportingbias")
library(reportingbias)
diabetes
diabetesM
data <- diabetes
diabetes.txt
read.delim(system.file("data", "diabetes.csv", package = "reportingbias")
)
system.file("data", "diabetes.csv", package = "reportingbias")
read.delim(system.file("data", "diabetes.txt", package = "reportingbias"))
read.csv(system.file("data", "diabetes.csv", package = "reportingbias"))
ls(package:"reportingbias")
ls(package:reportingbias)
library(devtools)
install_github("esm-ispm-unibe-ch/reportingbias")
library(reportingbias)
diabetesT
diabetes
read.csv(as.character(diabetes))
data <- read.csv("https://raw.githubusercontent.com/esm-ispm-unibe-ch/reportingbias/master/data/diabetes.csv")
View(data)
diabetes <- read.csv("~/Virginia/PhD project/reportingbias/data/diabetes.csv")
View(diabetes)
diabetes <- read.csv("~/Virginia/PhD project/reportingbias/data/diabetes.csv")
View(diabetes)
View(diabetes)
diabetes <- read.csv("~/Virginia/PhD project/reportingbias/data/diabetes.csv")
View(diabetes)
q()
diabetes <- read.csv("~/Virginia/PhD project/Publication bias/CINeMA/diabetes.csv")
View(diabetes)
diabetes <- read.csv("~/Virginia/PhD project/reportingbias/data/diabetes.csv")
View(diabetes)
diabetes <- read.csv("~/Virginia/PhD project/reportingbias/data/diabetes.csv")
View(diabetes)
View(diabetes)
rm(list=ls())
library(devtools)
install_github("esm-ispm-unibe-ch/reportingbias")
library(reportingbias)
diabetes
data("diabetes")
# download and store dataset
data <- read.csv("https://raw.githubusercontent.com/esm-ispm-unibe-ch/reportingbias/master/data/diabetes.csv")
# pairwise format
data.pw <- pairwise(t, r, n, data = data, studlab = id, sm="OR")
# run netmeta
nma1 <- netmeta(TE, seTE, treat1, treat2, studlab=studlab, data = data.pw)
library(nmathresh)
library(netmeta)
# pairwise format
data.pw <- pairwise(t, r, n, data = data, studlab = id, sm="OR")
# run netmeta
nma1 <- netmeta(TE, seTE, treat1, treat2, studlab=studlab, data = data.pw)
# threshold analysis
thresh1 <- threshold_netmeta(nma1, opt.max = F, mcid = 0.05)
threshplot(thresh1, nma1, xlab = "Log OR", xlim = c(-4,4))
nma_b <- netmeta(TE, seTE, treat1, treat2, studlab=studlab, data = data.pw, reference.group = "BBlocker")
nma1$TE.random
nma_b$TE.random
# threshold analysis
thresh1 <- threshold_netmeta(nma1, opt.max = F, mcid = 0.05)
threshplot(thresh1, nma1, xlab = "Log OR", xlim = c(-4,4))
thresh1
thresh1b <- threshold_netmeta(nma1, opt.max = F, decision = "change", mcid = 0.05)
threshplot(thresh1b, nma1, xlab = "Log OR", xlim = c(-4,4))
thresh1b <- threshold_netmeta(nma1, opt.max = F, decision = "change")
threshplot(thresh1b, nma1, xlab = "Log OR", xlim = c(-4,4))
# example(s) with network from database
library(nmadb)
NMADB <- getNMADB()
binaryIDs = NMADB[NMADB$Verified=="True" & NMADB$Type.of.Outcome.=="Binary" & NMADB$Format!="iv",]$Record.ID
continuousIDs = NMADB[NMADB$Verified=="True" & NMADB$Type.of.Outcome.=="Continuous" & NMADB$Format!="iv",]$Record.ID
NMADB[NMADB$Record.ID==474842, c("Primary.Outcome", "Harmful.Beneficial.Outcome")]
nma2 <- runnetmeta(474842)
summary(nma2)
thresh2 <- threshold_netmeta(nma2, opt.max = F, mcid = 0.1)
threshplot(thresh2, nma2, xlab = "Log OR")
thresh2b <- threshold_netmeta(nma2, opt.max = F, decision="change", mcid = 0.1)
threshplot(thresh2b, nma2, xlab = "Log OR")
Data(diabetes)
data(diabetes)
force(diabetes)
rm(list=ls())
Data(diabetes)
data(diabetes)
data(diabetes)
force(diabetes)
data(diabetes)
diabetes2
data("diabetes2")
View(diabetes2)
library(devtools)
install_github("esm-ispm-unibe-ch/reportingbias")
library(reportingbias)
library(nmathresh)
library(netmeta)
# download and store dataset
data <- data("diabetes")
force(diabetes)
